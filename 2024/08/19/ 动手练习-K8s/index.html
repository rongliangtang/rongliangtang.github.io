<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是RongLiang的博客,用来分享技术知识和一些感悟。"><title>动手练习 K8s | Tom's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">动手练习 K8s</h1><a id="logo" href="/.">Tom's Blog</a><p class="description">野蛮生长</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 文章</i></a><a href="/archives/"><i class="fa undefined"> 总览</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">动手练习 K8s</h1><div class="post-meta">2024-08-19</div><div class="post-content"><p>在上篇文章中，简单介绍了 K8s 的原理。单单通过文字，不足以帮助我们学习 K8s。所以本文通过实际的例子，由浅到深带大家在本地动手走一遍 K8s 的操作流程，旨在加深对 K8s 的理解。</p>
<p>我们将从最基础的 container 容器的定义出发，动手去跑 pod、deployment、service、ingress、namespace、configmap、secret、job 等操作的教程。<strong>下面的内容很干，跟着教程走一遍，相信你会大幅增加你对 K8s 的了解。</strong>在学习的过程中，不懂的及时问 GPT 或者查官方文档，这会事半功倍💪！</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始动手练习之前，请确保在本地配置好必要的环境。按照以下步骤进行设置：</p>
<h3 id="1-安装-Docker-Desktop"><a href="#1-安装-Docker-Desktop" class="headerlink" title="1. 安装 Docker Desktop"></a>1. 安装 Docker Desktop</h3><p>首先，点击这个 <a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop">链接</a> 下载 Docker Desktop。安装完成后，可以通过运行以下命令来验证是否成功安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h3 id="2-搭建本地-K8s-集群"><a href="#2-搭建本地-K8s-集群" class="headerlink" title="2. 搭建本地 K8s 集群"></a>2. 搭建本地 K8s 集群</h3><p>建议使用 Minikube 搭建本地 Kubernetes 集群，当然你也可以选择 Kind、Docker 自带的 K8s 等工具。对于 macOS 用户，可以通过以下命令快速安装 Minikube：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install minikube</span><br></pre></td></tr></table></figure>

<p>对于 Linux 和 Windows 用户，请参考 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/start">官方教程</a> 进行安装。</p>
<h3 id="3-启动本地-K8s-集群"><a href="#3-启动本地-K8s-集群" class="headerlink" title="3. 启动本地 K8s 集群"></a>3. 启动本地 K8s 集群</h3><p>安装完成后，你可以通过以下命令启动 Minikube：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --vm-driver docker --container-runtime=docker</span><br></pre></td></tr></table></figure>

<p>以下是 Minikube 的一些常用命令：</p>
<ul>
<li><code>minikube stop</code>：停止 VM 和 K8s 集群，但不会删除任何数据。</li>
<li><code>minikube delete</code>：删除所有 Minikube 启动后的数据。</li>
<li><code>minikube ip</code>：查看集群和 Docker Engine 运行的 IP 地址。</li>
<li><code>minikube pause</code>：暂停当前的资源和 K8s 集群。</li>
<li><code>minikube status</code>：查看当前集群状态。</li>
</ul>
<h3 id="4-安装-kubectl"><a href="#4-安装-kubectl" class="headerlink" title="4. 安装 kubectl"></a>4. 安装 kubectl</h3><p><code>kubectl</code> 是用于操作 Kubernetes 集群的命令行工具。你可以通过以下命令在 macOS 上快速安装 <code>kubectl</code>，其他操作系统的用户请参考 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/tools/">官方文档</a> 进行安装。</p>
<h3 id="5-注册-Docker-Hub-账号并登录"><a href="#5-注册-Docker-Hub-账号并登录" class="headerlink" title="5. 注册 Docker Hub 账号并登录"></a>5. 注册 Docker Hub 账号并登录</h3><p>为了便于发布 Docker 镜像供他人下载使用，并支持 Minikube 后续下载镜像，你需要在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a> 注册一个账号。注册完成后，通过以下命令登录你的 Docker Hub 账号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<p>完成以上步骤后，你的本地环境就配置好了，接下来可以开始实践 Kubernetes 的各种操作了！</p>
<h2 id="动手练习"><a href="#动手练习" class="headerlink" title="动手练习"></a>动手练习</h2><h3 id="使用-Docker-构建镜像"><a href="#使用-Docker-构建镜像" class="headerlink" title="使用 Docker 构建镜像"></a>使用 Docker 构建镜像</h3><h4 id="创建并发布-Docker-镜像"><a href="#创建并发布-Docker-镜像" class="headerlink" title="创建并发布 Docker 镜像"></a>创建并发布 Docker 镜像</h4><p>在本节中，我们将动手创建一个简单的 Java 应用镜像，并将其发布到 DockerHub 仓库，以便后续在 Minikube 中下载和使用。</p>
<p>首先，新建一个名为 <code>HelloKubernetes.java</code> 的文件，并将以下代码复制到文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;[v1] Hello, Kubernetes!&quot;</span>;</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段 Java 代码的功能非常简单：启动一个 HTTP 服务器，监听 <code>3000</code> 端口，并在访问根路径 <code>/</code> 时返回字符串 <code>[v1] Hello, Kubernetes!</code>。</p>
<p>在传统环境下，运行这段代码需要先安装 JDK，然后编译并运行。而通过容器技术，你只需准备好这段代码和对应的 Dockerfile，即使你对 Java 不熟悉，也能顺利运行这段代码。</p>
<blockquote>
<p>容器是一种基于 Linux 技术（如 Namespace、Cgroups、chroot 等）的沙盒环境。如果你想深入了解，可以参考这个 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8fi7uSYlOdc">视频</a>。</p>
</blockquote>
<h4 id="准备-Dockerfile"><a href="#准备-Dockerfile" class="headerlink" title="准备 Dockerfile"></a>准备 Dockerfile</h4><p>接下来，我们为上述 Java 代码准备对应的 <code>Dockerfile</code> 文件。这个 <code>Dockerfile</code> 使用了多阶段构建的方式。第一个阶段是使用轻量级的 <code>openjdk:8-jdk-alpine</code> 镜像来编译 Java 代码。第二个阶段则使用 <code>distroless</code> 镜像来提高安全性和减小镜像大小。即使你不理解 Dockerfile 的内容，也不会影响后续的操作。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 OpenJDK 8 的 Alpine 作为构建阶段的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工作目录 /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的所有文件复制到容器的 /src 目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Java 源代码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> javac HelloKubernetes.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 distroless 作为运行阶段的基础镜像，以提高安全性和减小镜像大小</span></span><br><span class="line"><span class="keyword">FROM</span> gcr.io/distroless/java-debian10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录为根目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从构建阶段复制所有编译好的字节码文件到运行阶段镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /src/ /app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置类路径，并运行应用程序</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-cp&quot;</span>, <span class="string">&quot;/app&quot;</span>, <span class="string">&quot;HelloKubernetes&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>将 <code>Dockerfile</code> 和 <code>HelloKubernetes.java</code> 文件放在同一目录下，然后通过以下命令构建镜像。<strong>请注意，将其中的 <code>tangrl177</code> 替换为你自己的 DockerHub 账号名</strong>，以便后续将镜像推送到你的 DockerHub 仓库中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t tangrl177/hellok8s:v1</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>docker images</code> 命令查看镜像是否构建成功。然后，通过以下命令启动容器，其中 <code>-p</code> 指定将容器的 <code>3000</code> 端口映射到主机，<code>-d</code> 表示在后台运行容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3000:3000 --name hellok8s -d tangrl177/hellok8s:v1</span><br></pre></td></tr></table></figure>

<p><strong>如果你使用的是 Mac 的 ARM 系统，请使用以下命令指定 <code>amd64</code> 平台来运行容器，以避免架构不匹配的问题：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --platform linux/amd64 -p 3000:3000 --name hellok8s -d tangrl177/hellok8s:v1</span><br></pre></td></tr></table></figure>

<p>容器启动成功后，你可以通过浏览器或 <code>curl</code> 命令访问 <code>http://127.0.0.1:3000</code>，验证是否成功返回字符串 <code>[v1] Hello, Kubernetes!</code>。</p>
<p>最后，使用 <code>docker push</code> 命令将镜像上传到 DockerHub，这样你和其他人都可以方便地下载和使用该镜像。<strong>再次提醒，将 <code>tangrl177</code> 替换为你自己的 DockerHub 账号名：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push tangrl177/hellok8s:v1</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你已经成功创建并发布了一个 Docker 镜像，为后续在 Kubernetes 中使用做好了准备。</p>
<h3 id="使用-Pod-部署应用"><a href="#使用-Pod-部署应用" class="headerlink" title="使用 Pod 部署应用"></a>使用 Pod 部署应用</h3><h4 id="Pod-和-Container-的区别"><a href="#Pod-和-Container-的区别" class="headerlink" title="Pod 和 Container 的区别"></a>Pod 和 Container 的区别</h4><p><code>Pod</code> 是 Kubernetes 中创建和管理的最小可部署单元，它与 <code>Container</code> 有着关键的区别。<code>Pod</code> 可以运行多个 <code>Container</code>，而 <code>Container</code> 的本质是进程，<code>Pod</code> 则是用于管理这些进程及其资源的单位。在某些场景下，例如服务之间需要进行文件交换（如日志收集），或者需要进行本地网络通信（通过 localhost 或 Socket 文件进行本地通信），<code>Pod</code> 的这种多容器管理方式非常有用。</p>
<h4 id="Pod-相关练习-1"><a href="#Pod-相关练习-1" class="headerlink" title="Pod 相关练习 1"></a>Pod 相关练习 1</h4><p>通过以下练习，我们将进一步理解 <code>Pod</code> 的概念。</p>
<p>首先，我们创建一个名为 <code>nginx.yaml</code> 的文件，编写用于运行 <code>nginx</code> 容器的 <code>Pod</code> 定义文件。文件内容如下所示，其中 <code>kind</code> 表示我们要创建的资源类型为 <code>Pod</code>，<code>metadata.name</code> 用于指定 <code>Pod</code> 的名称，这个名称在集群中需要唯一。<code>spec.containers</code> 用于定义运行的容器名称及其使用的镜像。默认情况下，镜像来源于 DockerHub。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>接下来，运行以下命令来创建 <code>nginx</code> Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 nginx Pod</span></span><br><span class="line">kubectl apply -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>使用 <code>kubectl get pods</code> 命令查看 Pod 是否成功启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 pod 是否正常启动</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<p>然后，使用以下命令将 <code>nginx</code> 容器的默认 <code>80</code> 端口映射到本机的 <code>4000</code> 端口，打开浏览器或使用 <code>curl</code> 命令访问 <code>http://127.0.0.1:4000</code>，验证是否成功访问到 <code>nginx</code> 的默认页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 nginx 默认的 80 端口映射到本机的 4000 端口</span></span><br><span class="line">kubectl port-forward nginx-pod 4000:80</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>kubectl exec -it</code> 命令进入 Pod 内部的容器 Shell，并修改 <code>nginx</code> 的首页内容。通过以下命令进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 Pod 容器的 Shell</span></span><br><span class="line">kubectl exec -it nginx-pod /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 Pod 容器的 Shell 后执行，修改 `nginx` 的首页内容</span></span><br><span class="line">echo &quot;hello kubernetes by nginx!&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出 Pod 容器的 Shell 并重新映射端口</span></span><br><span class="line">exit</span><br><span class="line">kubectl port-forward nginx-pod 4000:80</span><br></pre></td></tr></table></figure>

<p>然后再次访问 <code>http://127.0.0.1:4000</code>，确保 <code>nginx</code> 成功启动并返回自定义的字符串 <code>hello kubernetes by nginx!</code>。</p>
<h4 id="Pod-相关练习-2"><a href="#Pod-相关练习-2" class="headerlink" title="Pod 相关练习 2"></a>Pod 相关练习 2</h4><p>接下来，我们使用之前在 <code>Container</code> 小节中构建的 <code>hellok8s:v1</code> 镜像，参考 <code>nginx</code> Pod 的资源定义文件，编写 <code>hellok8s:v1</code> Pod 的资源定义文件。通过 <code>port-forward</code> 将 Pod 的端口转发到本地 <code>3000</code> 端口，最终你将会看到 <code>[v1] Hello, Kubernetes!</code> 的输出。</p>
<p>以下是 <code>hellok8s:v1 Pod</code> 的资源定义文件和相应的命令。请注意，<code>tangrl177</code> 应该替换为你自己的 DockerHub 账号名：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v1</span></span><br></pre></td></tr></table></figure>

<p>运行以下命令来启动和访问 <code>hellok8s</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f hellok8s.yaml</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl port-forward hellok8s 3000:3000</span><br></pre></td></tr></table></figure>

<h4 id="解决-Pod-启动失败"><a href="#解决-Pod-启动失败" class="headerlink" title="解决 Pod 启动失败"></a>解决 Pod 启动失败</h4><p>如果 Pod 的状态显示为 <code>ErrImagePull</code> 或 <code>ImagePullBackOff</code>，这可能是由于网络问题导致无法从 DockerHub 拉取镜像。此时，你可以运行以下命令来解决问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure>

<p>然后重新构建镜像，而无需将其推送到 DockerHub。这样，构建的镜像可以直接被 Minikube 获取，避免了 DockerHub 拉取镜像的延迟或失败。</p>
<p><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/pushing/">上述解决方法来源于官方文档</a></p>
<h4 id="Pod-相关命令"><a href="#Pod-相关命令" class="headerlink" title="Pod 相关命令"></a>Pod 相关命令</h4><p>以下是一些常用的 <code>kubectl</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 pod 日志</span></span><br><span class="line">kubectl logs --follow nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 pod 内部容器的 Shell 或执行容器命令</span>                              </span><br><span class="line">kubectl exec nginx -- ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 pod 资源</span></span><br><span class="line">kubectl delete pod nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 pod 的配置文件</span></span><br><span class="line">kubectl delete -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>你可以参考 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/">官方文档</a> 获取 <code>kubectl</code> 支持的所有命令。</p>
<h3 id="使用-Deployment-管理应用部署"><a href="#使用-Deployment-管理应用部署" class="headerlink" title="使用 Deployment 管理应用部署"></a>使用 Deployment 管理应用部署</h3><p>在实际的生产环境中，我们通常不会直接管理 Pod，而是使用 Kubernetes 的 <code>Deployment</code> 资源来帮助管理 Pod。<code>Deployment</code> 可以执行自动扩容、自动升级等操作。例如，如果你已经部署了 10 个 <code>hellok8s:v1</code> 的 Pod，需要扩容到 20 个，或者需要将它们升级为 <code>hellok8s:v2</code> 版本，那么 <code>Deployment</code> 将是最佳选择。</p>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p><strong>在进行以下练习之前，建议通过 <code>kubectl get pods</code> 查看并删除上一节创建的 Pod。如果 Pod 是通过 Deployment 创建的，则需要使用 <code>kubectl delete deployments xxx</code> 删除相应的 Deployment 资源。</strong></p>
<p>首先，创建一个 <code>deployment.yaml</code> 文件，用来管理 <code>hellok8s</code> Pod。其中，<code>kind</code> 表示资源类型为 <code>Deployment</code>，<code>metadata.name</code> 定义了 Deployment 的名称，这个名称必须<strong>唯一</strong>。</p>
<p>在 <code>spec</code> 中，<code>replicas</code> 指定 Pod 的副本数量，<code>selector</code> 定义了 Deployment 如何关联 Pod。在这个例子中，<code>Deployment</code> 会管理所有 <code>labels=hellok8s</code> 的 Pod。</p>
<p><code>template</code> 用来定义 Pod 资源的结构。你会发现它与前面 Hellok8s Pod 资源的定义非常相似。唯一的区别是，我们在 <code>template</code> 中添加了 <code>metadata.labels</code> 来与 <code>selector.matchLabels</code> 对应，标明 Pod 是由这个 Deployment 管理的。Deployment 会为我们自动生成 Pod 的唯一 <code>name</code>，所以在 <code>template</code> 中无需手动定义 <code>metadata.name</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">guangzhengli/hellok8s:v1</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<p>使用以下命令来创建 Deployment 资源。你可以通过 <code>get</code> 和 <code>delete pod</code> 命令来体验 Deployment 的功能。<strong>请注意，每次创建的 Pod 名称都会变化，因此某些命令需要替换为你当前 Pod 的名称。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 deployment</span></span><br><span class="line">kubectl apply -f deployment.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 deployment</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 pod 的信息</span></span><br><span class="line">kubectl get pods             </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 pod</span></span><br><span class="line">kubectl delete pod hellok8s-deployment-xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取新的 pod，你会发现删除一个 pod 后，deployment 会自动生成一个新的 pod</span></span><br><span class="line">kubectl get pods                                       </span><br></pre></td></tr></table></figure>

<p>你会发现，当你手动删除一个 <code>Pod</code> 资源后，Deployment 会自动创建一个新的 <code>Pod</code>。这与我们之前手动创建 Pod 资源的方式有很大的区别🤯！这意味着在生产环境中管理成千上万个 Pod 时，我们不需要逐个管理，只需维护好 <code>deployment.yaml</code> 文件的资源定义即可。</p>
<p>接下来，通过自动扩容来进一步理解 Deployment 的优势。当我们需要将 <code>hellok8s:v1</code> 的副本数量扩容到 3 个时，只需将 <code>replicas</code> 的值设置为 3，然后重新执行 <code>kubectl apply -f deployment.yaml</code>。如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">guangzhengli/hellok8s:v1</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<p>你可以在执行 <code>kubectl apply</code> 之前，新建一个命令行窗口并执行 <code>kubectl get pods --watch</code>，实时观察 Pod 启动和删除的过程。减少副本数的方法也很简单，只需将 <code>replicas</code> 的值减少即可。</p>
<h4 id="升级版本"><a href="#升级版本" class="headerlink" title="升级版本"></a>升级版本</h4><p>接下来，我们将所有 <code>v1</code> 版本的 <code>Pod</code> 升级到 <code>v2</code> 版本。首先，需要构建 <code>hellok8s:v2</code> 的镜像，唯一的区别是将响应字符串替换为 <code>[v2] Hello, Kubernetes!</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;[v2] Hello, Kubernetes!&quot;</span>;</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，按照之前的步骤构建镜像并将其推送到 DockerHub 仓库中。<strong>记得将 <code>tangrl177</code> 替换为你自己的 DockerHub 账号名。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:v2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将镜像推送到 DockerHub 仓库</span></span><br><span class="line">docker push tangrl177/hellok8s:v2</span><br></pre></td></tr></table></figure>

<p>接着，更新 <code>deployment.yaml</code> 文件，以使用 <code>v2</code> 版本的镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v2</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<p>最后，执行以下命令更新配置，并在浏览器中打开 <code>http://localhost:3000</code>，查看输出是否已更新为 <code>v2</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新配置</span></span><br><span class="line">kubectl apply -f deployment.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 pod 详情</span></span><br><span class="line">kubectl get pods </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射某个 pod 的端口，注意更换 pod 名称</span></span><br><span class="line">kubectl port-forward hellok8s-deployment-xxx 3000:3000</span><br></pre></td></tr></table></figure>

<h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>在生产环境中，如果你需要管理多个 <code>hellok8s:v1</code> 副本并将其升级到 <code>v2</code> 版本，直接替换所有 Pod 的方式可能会带来问题。因为这会导致服务在升级过程中不可用——旧版本的 Pod 会被删除，而新版本的 Pod 尚未完全就绪。</p>
<p>这时，你可以使用滚动更新（Rolling Update）来逐步替换旧版本的 Pod，而不影响服务的可用性。在 <code>Deployment</code> 资源定义中，<code>spec.strategy.type</code> 有两种选择：</p>
<ul>
<li><strong>RollingUpdate:</strong> 逐步增加新版本的 Pod，同时逐步减少旧版本的 Pod。</li>
<li><strong>Recreate:</strong> 在增加新版本的 Pod 之前，先删除所有旧版本的 Pod。</li>
</ul>
<p>通常情况下，我们会选择滚动更新（RollingUpdate）。滚动更新可以通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 字段来控制升级 Pod 的速率，具体细节可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">官方文档</a>。</p>
<ul>
<li><strong>maxSurge:</strong> 最大峰值，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。</li>
<li><strong>maxUnavailable:</strong> 最大不可用数量，用来指定更新过程中不可用的 Pod 的上限。</li>
</ul>
<p>你可以使用以下命令回滚 Deployment。通过端口映射测试，验证回滚是否符合预期。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚 deployment</span></span><br><span class="line">kubectl rollout undo deployment hellok8s-deployment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 pod 详情</span></span><br><span class="line">kubectl get pods                                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询某个 pod 的信息，注意替换 pod 名称</span></span><br><span class="line">kubectl describe pod hellok8s-deployment-xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出应包含 Image: tangrl177/hellok8s:v1</span></span><br></pre></td></tr></table></figure>

<p>除了上述命令，还可以使用 <code>history</code> 查看历史版本，并通过 <code>--to-revision=2</code> 回滚到指定版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout history deployment hellok8s-deployment</span><br><span class="line">kubectl rollout undo deployment/hellok8s-deployment --to-revision=2</span><br></pre></td></tr></table></figure>

<p>接下来，在 <code>deployment.yaml</code> 文件中设置 <code>strategy=rollingUpdate</code>，<code>maxSurge=1</code>，<code>maxUnavailable=1</code>，并将 <code>replicas</code> 设置为 3。这意味着最大可能会创建 4 个 <code>hellok8s</code> Pod（<code>replicas + maxSurge</code>），最少会有 2 个 &#96;hell</p>
<p>ok8s<code> Pod 存活（</code>replicas - maxUnavailable&#96;）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">     <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<img src="https://blog-1259405505.cos.ap-guangzhou.myqcloud.com/rollingupdate-20240820110828004.png" alt="滚动更新示意图（图片来自Kubernetes练习手册）" style="zoom:60%;" />

<h4 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h4><p>存活探针（Liveness Probe）用于检测容器是否需要重启。例如，探针可以探测到应用的死锁情况（应用程序在运行，但无法继续执行后续步骤）。重启此类容器有助于提高应用的可用性，尽管其中可能存在缺陷。</p>
<p>在生产环境中，某些 Bug 可能导致应用死锁或线程耗尽，最终使应用无法继续提供服务。如果没有手段自动监控和处理这种情况，问题可能会持续很长时间而不被发现。Kubelet 使用存活探针来确定何时重启容器。</p>
<p>接下来，我们编写一个 <code>/health</code> 接口来说明存活探针的工作原理。这个接口会在服务器启动后的 15 秒内正常返回 200 状态码，但在 15 秒后将一直返回 500 状态码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 记录服务器启动时间</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">started</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;[v2] Hello, Kubernetes!&quot;</span>;</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问 /health 时返回健康检查结果</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/health&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(started, Instant.now());</span><br><span class="line">                String response;</span><br><span class="line">                <span class="keyword">if</span> (duration.getSeconds() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                    response = <span class="string">&quot;error: &quot;</span> + duration.getSeconds();</span><br><span class="line">                    exchange.sendResponseHeaders(<span class="number">500</span>, response.getBytes().length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    response = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">                    exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dockerfile 内容保持不变。构建镜像时，将 Tag 设置为 <code>liveness</code>，并推送到远程仓库。如果镜像拉取失败，请参考 Pod 小节中的 “解决 Pod 启动失败” 部分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:liveness</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将镜像推送到 DockerHub</span></span><br><span class="line">docker push tangrl177/hellok8s:liveness</span><br></pre></td></tr></table></figure>

<p>最后，编写 Deployment 的定义文件。在这里，我们使用 HTTP GET 请求方式的存活探针，探测刚才定义的 <code>/health</code> 接口。<code>periodSeconds</code> 字段指定 Kubelet 每隔 3 秒执行一次存活探测。<code>initialDelaySeconds</code> 字段告诉 Kubelet 在执行第一次探测前应该等待 3 秒。如果 <code>/health</code> 路径返回成功代码，则 Kubelet 认为容器是健康的。如果返回失败代码，Kubelet 会重启容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">     <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:liveness</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>get</code> 或 <code>describe</code> 命令可以发现 Pod 一直处于重启状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚 deployment</span></span><br><span class="line">kubectl rollout undo deployment hellok8s-deployment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 pod 详情</span></span><br><span class="line">kubectl get pods                                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询某个 pod 的信息，注意替换 pod 名称</span></span><br><span class="line">kubectl describe pod hellok8s-deployment-xxx</span><br></pre></td></tr></table></figure>

<h4 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h4><p>就绪探针（Readiness Probe）用于检测容器何时准备好接收请求流量。<strong>只有当一个 Pod 内的所有容器都就绪时，Pod 才会被视为就绪</strong>。这种信号的一个用途是控制哪些 Pod 作为 Service 的后端。如果 Pod 尚未就绪，它将从 Service 的负载均衡器中剔除。</p>
<p>在生产环境中，升级服务版本是日常需求。如果发布的版本存在问题，就不应该让它升级成功。Kubelet 使用就绪探针来检测容器是否准备好接受请求流量。如果 Pod 升级后不能就绪，则不应让流量进入该 Pod，并且配合 <code>rollingUpdate</code> 功能，防止不稳定版本的 Pod 升级。</p>
<p>在以下示例中，我们将 <code>/health</code> 接口设置为始终返回 500 状态码，模拟一个有问题的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 记录服务器启动时间</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">started</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;[v2] Hello, Kubernetes!&quot;</span>;</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问 /health 时返回健康检查结果</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/health&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">500</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dockerfile 内容保持不变。构建镜像时，将 Tag 设置为 <code>bad</code>，并推送到远程仓库。如果镜像拉取失败，请参考 Pod 小节中的 “解决 Pod 启动失败” 部分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:bad</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将镜像推送到 DockerHub</span></span><br><span class="line">docker push tangrl177/hellok8s:bad</span><br></pre></td></tr></table></figure>

<p>接着编写 Deployment 资源文件。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core">Probe</a> 提供了许多配置字段，可以用来精确控制就绪探针的行为：</p>
<ul>
<li><code>initialDelaySeconds</code>: 容器启动后等待多少秒后才启动存活和就绪探针，默认值为 0 秒，最小值为 0。</li>
<li><code>periodSeconds</code>: 探测的时间间隔（单位为秒），默认值为 10 秒，最小值为 1。</li>
<li><code>timeoutSeconds</code>: 探测超时时的等待时间，默认值为 1 秒，最小值为 1。</li>
<li><code>successThreshold</code>: 探测失败后，视为成功的最小连续成功数，默认值为 1。对于存活和启动探针，这个值必须为 1，最小</li>
</ul>
<p>值为 1。</p>
<ul>
<li><code>failureThreshold</code>: 探测失败时 Kubernetes 的重试次数。对于存活探针，放弃探测意味着重新启动容器；对于就绪探针，放弃探测意味着 Pod 会被标记为未就绪。默认值为 3，最小值为 1。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">     <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:bad</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>get</code> 命令可以发现两个 Pod 一直处于未就绪状态。使用 <code>describe</code> 命令可以看到失败原因是 <code>Readiness probe failed: HTTP probe failed with status code: 500</code>。由于设置了 <code>maxUnavailable=1</code>，确保剩余两个 <code>v2</code> 版本的 <code>hellok8s</code> Pod 仍能继续提供服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚 deployment</span></span><br><span class="line">kubectl rollout undo deployment hellok8s-deployment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 pod 详情</span></span><br><span class="line">kubectl get pods                                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询某个 pod 的信息，注意替换 pod 名称</span></span><br><span class="line">kubectl describe pod hellok8s-deployment-xxx</span><br></pre></td></tr></table></figure>

<h3 id="使用-Service-管理应用访问和负载均衡"><a href="#使用-Service-管理应用访问和负载均衡" class="headerlink" title="使用 Service 管理应用访问和负载均衡"></a>使用 Service 管理应用访问和负载均衡</h3><p>经过前面的练习，你可能会有以下疑问：</p>
<ul>
<li>当 Pod 未就绪（Ready）时，<code>Kubernetes</code> 为什么不会将流量重定向到该 Pod？这是如何实现的？</li>
<li>之前通过 <code>port-forward</code> 将 Pod 的端口暴露到本地，既需要准确填写 Pod 的名称，还要面对 Deployment 重新创建新 Pod 时，Pod 名称和 IP 地址会随之变化的问题。如何保证访问地址的稳定性？</li>
<li>如果使用 Deployment 部署了多个 Pod 副本，如何实现负载均衡？</li>
</ul>
<p>为了解决这些问题，<code>Kubernetes</code> 提供了一种名为 <code>Service</code> 的资源。<code>Service</code> 为 Pod 提供了一个稳定的访问端点（Endpoint）。它位于 Pod 的前面，负责接收请求并将它们传递给后面的所有 Pod。一旦服务中的 Pod 集合发生变化，Endpoints 也会随之更新，确保请求总是能够重定向到最新的 Pod。</p>
<h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p><code>Service</code> 默认使用 <code>ClusterIP</code> 类型。在进一步练习之前，我们将之前的 <code>hellok8s:v2</code> 升级为 <code>v3</code> 版本，并添加返回当前服务所在主机名的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取主机名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hostname = InetAddress.getLocalHost().getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            hostname = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> String.format(<span class="string">&quot;[v3] Hello, Kubernetes!, From host: %s&quot;</span>, hostname);</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保持 Dockerfile 不变，在构建镜像时将 Tag 设置为 <code>v3</code>，并推送到远程仓库。如果遇到镜像拉取问题，请参考 Pod 小节中的“解决 Pod 启动失败”部分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:v3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">push 镜像到 DockerHub</span></span><br><span class="line">docker push tangrl177/hellok8s:v3</span><br></pre></td></tr></table></figure>

<p>修改 Deployment，将 <code>hellok8s</code> 升级为 <code>v3</code> 版本。执行 <code>kubectl apply -f deployment.yaml</code> 更新 Deployment。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v3</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<p>接着，定义 <code>Service</code> 资源，使用 <code>ClusterIP</code> 类型。<code>ClusterIP</code> 通过集群内部 IP 暴露服务，当我们只需要让集群中运行的其他应用程序访问 Pod 时，可以使用这种类型的 Service。首先，创建一个 <code>service-hellok8s-clusterip.yaml</code> 文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service-hellok8s-clusterip.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-hellok8s-clusterip</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>通过以下命令查看 Endpoints 信息。<code>Selector</code> 选中的 Pod 称为 Service 的 Endpoints，它维护着 Pod 的 IP 地址。只要服务中的 Pod 集合发生变化，Endpoints 就会被更新。使用 <code>kubectl get pod -o wide</code> 可以看到 3 个 Pod 的 IP 地址与 Endpoints 中的信息保持一致。你可以尝试增加或减少 Deployment 中 Pod 的副本数，观察 Endpoints 是否随之变化。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新配置</span></span><br><span class="line">kubectl apply -f service-hellok8s-clusterip.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Endpoints</span></span><br><span class="line">kubectl get endpoints</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Pod 更多信息，可以看到 3 个 Pod 的 IP 地址与 Endpoints 保持一致</span></span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Service 信息</span></span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>

<p>接着，我们可以通过<strong>集群内的其他应用程序</strong>访问 <code>service-hellok8s-clusterip</code> 的 IP 地址，从而访问 <code>hellok8s:v3</code> 服务。</p>
<p>你可以通过执行 <code>kubectl apply -f deployment-nginx.yaml</code> 在集群内创建一个 <code>nginx</code> 来访问 <code>hellok8s</code> 服务。然后通过执行 <code>kubectl exec -it nginx-pod /bin/bash</code> 进入 <code>nginx</code> 容器，并使用 <code>curl</code> 命令访问 <code>service-hellok8s-clusterip</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment-nginx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>在容器内多次执行 <code>curl</code>，你会发现返回的 <code>hellok8s:v3</code> hostname 不同，这表明 Service 可以接收请求并将它们传递给后面的所有 Pod，同时自动实现负载均衡。调用过程如下图所示：</p>
<img src="https://blog-1259405505.cos.ap-guangzhou.myqcloud.com/service-clusterip-fix-name-20240820111257192.png" alt="Service ClusterIP 负载均衡示意图（图片来自Kubernetes练习手册）" style="zoom:60%;" />

<p>Kubernetes <code>ServiceTypes</code> 允许指定 Service 类型，默认是 <code>ClusterIP</code>。其他可用的 <code>Type</code> 包括：</p>
<ul>
<li>ClusterIP：通过集群的内部 IP 暴露服务，仅能在集群内部访问。这是默认的 <code>ServiceType</code>。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport">NodePort</a>：通过每个节点的 IP 和静态端口（<code>NodePort</code>）暴露服务。<code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群外部访问 <code>NodePort</code> 服务。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer">LoadBalancer</a>：使用云提供商的负载均衡器向外部暴露服务。外部负载均衡器将流量路由到自动创建的 <code>NodePort</code> 和 <code>ClusterIP</code> 服务。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname">ExternalName</a>：通过返回 <code>CNAME</code> 和对应值，将服务映射到 <code>externalName</code> 字段的内容（例如 <code>foo.bar.example.com</code>）。无需创建任何类型的代理。</li>
</ul>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p>我们知道 <code>Kubernetes</code> 集群并不是单机运行，它管理着多台节点（<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/">Node</a>）。<code>NodePort</code> 类型的 Service 通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。如下图所示，如果集群中有两台 Node 运行着 <code>hellok8s:v3</code>，我们可以创建一个 <code>NodePort</code> 类型的 Service，将 <code>hellok8s:v3</code> 的 <code>3000</code> 端口映射到 Node 机器的 <code>30000</code> 端口（端口范围为 30000-32767）。这样我们就可以通过访问 <code>http://node1-ip:30000</code> 或 <code>http://node2-ip:30000</code> 来访问服务。</p>
<img src="https://blog-1259405505.cos.ap-guangzhou.myqcloud.com/service-nodeport-fix-name-20240820111257495.png" alt="NodePort 服务架构图（图片来自Kubernetes练习手册）" style="zoom:60%;" />

<p>以 <code>minikube</code> 为例，你可以通过 <code>minikube ip</code> 命令获取 k8s 集群节点的 IP 地址。下面的教程以我的本机 IP <code>192.168.49.2</code> 为例，请替换成你自己的 IP 地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube ip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.49.2</span></span><br></pre></td></tr></table></figure>

<p>接着，我们创建一个 NodePort 类型的 Service 来接管 Pod 流量。通过 <code>minikube</code> 节点上的 IP <code>192.168.49.2</code> 暴露服务。<code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。通过请求 <code>&lt;节点IP&gt;:&lt;节点端口&gt;</code>——<code>192.168.49.2:6000</code>，你可以从集群外部访问 <code>NodePort</code> 服务，最终将请求重定向到 <code>hellok8s:v3</code> 的 <code>3000</code> 端口。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service-hellok8s-nodeport.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-hellok8s-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>

<p>创建 <code>service-hellok8s-nodeport</code> Service 后，使用 <code>curl</code> 命令或浏览器访问 <code>http://192.168.49.2:6000</code> 可以得到结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f service-hellok8s-nodeport.yaml</span><br><span class="line">kubectl get service</span><br><span class="line">kubectl get pods</span><br><span class="line">curl http://192.168.49.2:6000</span><br><span class="line">curl http://192.168.49.2:6000</span><br><span class="line">curl http://192.168.49.2:6000</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 Docker Desktop（<code>minikube start --driver=docker</code>），可能无法通过 <code>minikube ip</code> 获取的 IP 地址访问服务，因为 Docker 的网络限制导致无法直接连接 Docker 容器。这意味着 NodePort 类型的 Service 和 Ingress 组件都无法通过 <code>minikube ip</code> 提供的 IP 地址访问。此时，可以通过 <code>minikube service service-hellok8s-nodeport --url</code> 来公开服务，然后使用 <code>curl</code> 或浏览器访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minikube service service-hellok8s-nodeport --url</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出 http://127.0.0.1:54724</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为你在 Windows 上使用 Docker driver，终端需要保持打开状态。</span></span><br><span class="line">curl http://127.0.0.1:54724</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-559cfdd58c-zp2pc</span></span><br><span class="line">curl http://127.0.0.1:54724</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-559cfdd58c-2j2x2</span></span><br></pre></td></tr></table></figure>

<h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a> 类型的 Service 使用云提供商的负载均衡器向外部暴露服务。外部负载均衡器将流量路由到自动创建的 <code>NodePort</code> 和 <code>ClusterIP</code> 服务。如果你在 <a target="_blank" rel="noopener" href="https://aws.amazon.com/">AWS</a> 的 <a target="_blank" rel="noopener" href="https://aws.amazon.com/eks/">EKS</a> 集群上创建一个 <code>LoadBalancer</code> 类型的 Service，Kubernetes 会自动创建一个 ELB（<a target="_blank" rel="noopener" href="https://aws.amazon.com/elasticloadbalancing">Elastic Load Balancer</a>），并从配置的 IP 池中分配一个独立的 IP 地址供外部访问。</p>
<p>由于我们使用的是 <code>minikube</code>，可以通过 <code>minikube tunnel</code> 来模拟创建 LoadBalancer 的 <code>EXTERNAL_IP</code>。具体教程可以参考<a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access">官网文档</a>。不过，minikube 模拟的 LoadBalancer 与实际云提供商提供的 LoadBalancer 有本质区别。如果你有条件，可以在 <a target="_blank" rel="noopener" href="https://aws.amazon.com/">AWS</a> 的 <a target="_blank" rel="noopener" href="https://aws.amazon.com/eks/">EKS</a> 集群上创建一个 ELB 进行测试。</p>
<p>下图显示了 LoadBalancer 的 Service 架构。</p>
<img src="https://blog-1259405505.cos.ap-guangzhou.myqcloud.com/service-loadbalancer-fix-name-20240820111257643.png" alt="LoadBalancer 服务架构图（图片来自Kubernetes练习手册）" style="zoom:60%;" />

<h3 id="使用-Ingress-管理外部流量路由"><a href="#使用-Ingress-管理外部流量路由" class="headerlink" title="使用 Ingress 管理外部流量路由"></a>使用 Ingress 管理外部流量路由</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#ingress-v1beta1-networking-k8s-io">Ingress</a> 资源用于公开从集群外部到集群内部 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> 的 HTTP 和 HTTPS 路由。流量的路由由 Ingress 资源上定义的规则控制。通过 Ingress，可以为 Service 提供外部可访问的 URL、负载均衡流量、SSL&#x2F;TLS 支持以及基于名称的虚拟主机。不过，需要注意的是，你必须拥有一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers">Ingress 控制器</a> 才能使 Ingress 生效。仅创建 Ingress 资源本身不会产生任何效果。Ingress 控制器通常负责通过负载均衡器实现 Ingress，例如 <code>minikube</code> 默认使用 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/">nginx-ingress</a>，此外 <code>minikube</code> 还支持 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/addons/kong-ingress/">Kong-Ingress</a>。</p>
<p>简单来说，Ingress 可以被视为服务的网关（Gateway），它是集群中所有流量的入口，并根据配置的路由规则，将流量重定向到后端的服务。</p>
<p>在 <code>minikube</code> 中，可以通过以下命令启用 Ingress 控制器功能，默认使用 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/">nginx-ingress</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube addons enable ingress</span><br></pre></td></tr></table></figure>

<p><strong>接下来删除之前创建的所有 <code>Pod</code>、<code>Deployment</code> 和 <code>Service</code> 资源。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment,service --all</span><br></pre></td></tr></table></figure>

<p>然后，按照之前的教程，重新创建 <code>hellok8s:v3</code> 和 <code>nginx</code> 的 <code>Deployment</code> 和 <code>Service</code> 资源，Service 的类型设为 <code>ClusterIP</code>。</p>
<p><code>hellok8s:v3</code> 的端口映射为 <code>3000:3000</code>，<code>nginx</code> 的端口映射为 <code>4000:80</code>，这些端口映射将在后续编写 Ingress 路由规则时使用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-hellok8s-clusterip</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hellok8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">guangzhengli/hellok8s:v3</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nginx-clusterip</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">4000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx-container</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f hellok8s.yaml </span><br><span class="line">kubectl apply -f nginx.yaml </span><br><span class="line">kubectl get pods   </span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>

<p>现在，集群中有 3 个 <code>hellok8s:v3</code> 的 Pod 和 2 个 <code>nginx</code> 的 Pod。<code>hellok8s:v3</code> 的端口映射为 <code>3000:3000</code>，<code>nginx</code> 的端口映射为 <code>4000:80</code>。在此基础上，我们接下来将编写 Ingress 资源定义，其中 <code>nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;</code> 表示关闭 HTTPS 连接，仅使用 HTTP 连接。</p>
<p>我们将匹配前缀为 <code>/hello</code> 的路由规则，重定向到 <code>hellok8s:v3</code> 服务；匹配前缀为 <code>/</code> 的根路径，将流量重定向到 <code>nginx</code> 服务。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="comment"># 该注解用于暂时关闭 nginx 的 https 重定向</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">service-hellok8s-clusterip</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">3000</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">service-nginx-clusterip</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ingress.yaml</span><br><span class="line">kubectl get ingress          </span><br><span class="line">curl http://192.168.49.2/hello</span><br><span class="line">curl http://192.168.49.2/</span><br></pre></td></tr></table></figure>

<p>和 <code>Service</code> 类似，如果你使用的是 Docker Desktop（<code>minikube start --driver=docker</code>），可能无法通过 <code>minikube ip</code> 获取的 IP 地址访问服务。你可以先通过 <code>minikube service list</code> 查看服务列表，然后使用 <code>minikube service ingress-nginx-controller -n ingress-nginx --url</code> 来公开服务，再通过 <code>curl</code> 或浏览器访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minikube service list</span><br><span class="line">minikube service ingress-nginx-controller -n ingress-nginx --url</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出如下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://127.0.0.1:55201	http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://127.0.0.1:55202	https</span></span><br><span class="line">curl http://127.0.0.1:55201/hello</span><br><span class="line">curl http://127.0.0.1:55201/</span><br></pre></td></tr></table></figure>

<p>在上面的教程中，我们将所有流量发送到 Ingress 中，如下图所示：</p>
<img src="https://blog-1259405505.cos.ap-guangzhou.myqcloud.com/ingress-20240820111904568.png" alt="Ingress 流量示意图（图片来自Kubernetes练习手册）" style="zoom:60%;" />

<h3 id="使用-Namespace-隔离不同环境的资源"><a href="#使用-Namespace-隔离不同环境的资源" class="headerlink" title="使用 Namespace 隔离不同环境的资源"></a>使用 Namespace 隔离不同环境的资源</h3><p>在实际的开发过程中，我们经常需要为不同的环境设置独立的资源配置，例如 <code>dev</code> 环境供开发使用，<code>test</code> 环境供 QA 使用。这样可以保证各个环境的资源互相隔离，互不干扰。那么，Kubernetes 是否可以帮助我们在不同环境（如 <code>dev</code>、<code>test</code>、<code>uat</code>、<code>prod</code>）中区分资源，使得它们独立存在呢？答案是肯定的，Kubernetes 提供了一种名为 Namespace 的机制来帮助实现资源隔离。</p>
<p>在 Kubernetes 中，<strong>命名空间（Namespace）</strong> 是一种将同一集群中的资源划分为相互隔离的组的机制。同一个命名空间内的资源名称必须唯一，但跨命名空间时则没有这个限制。命名空间主要作用于带有命名空间属性的对象，例如 Deployment、Service 等。</p>
<p>在之前的教程中，我们默认使用的是 <code>default</code> 命名空间。接下来，我们将展示如何创建新的命名空间，以及如何在这些命名空间下管理资源。</p>
<p>首先，以下是一个定义了两个不同命名空间（<code>dev</code> 和 <code>test</code>）的 <code>namespace.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namespaces.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>你可以通过以下命令创建这两个新的命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f namespaces.yaml  </span><br><span class="line">kubectl get namespaces </span><br></pre></td></tr></table></figure>

<p>创建完成后，我们就有了 <code>dev</code> 和 <code>test</code> 两个独立的命名空间。那么如何在这些命名空间下创建资源并获取资源呢？只需要在命令后面加上 <code>-n &lt;namespace&gt;</code> 参数即可。例如，我们可以在 <code>dev</code> 命名空间下创建 <code>hellok8s:v3</code> 的 Deployment 资源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml -n dev</span><br><span class="line">kubectl get pods -n dev</span><br></pre></td></tr></table></figure>

<p>通过这种方式，Kubernetes 的 Namespace 能够有效地帮助我们在不同环境中隔离资源，使得 <code>dev</code>、<code>test</code>、<code>uat</code>、<code>prod</code> 等环境的资源能够独立管理，互不影响。</p>
<h3 id="使用-ConfigMap-管理环境配置"><a href="#使用-ConfigMap-管理环境配置" class="headerlink" title="使用 ConfigMap 管理环境配置"></a>使用 ConfigMap 管理环境配置</h3><p>在前面的内容中我们提到过，在不同的环境（如 <code>dev</code>、<code>test</code>、<code>uat</code>、<code>prod</code>）中区分资源，可以使各环境的资源相互独立，互不干扰。然而，这也带来了一些新的挑战。例如，不同环境的数据库地址通常是不一样的，如果在代码中写死同一个数据库地址，就会导致问题。</p>
<p>为了解决这个问题，Kubernetes 提供了 ConfigMap，将配置信息与应用程序代码分离。ConfigMap 用于保存非机密性的键值对数据，方便在不同环境中灵活配置。例如，不同环境的数据库地址可以通过 ConfigMap 来管理。需要注意的是，ConfigMap 设计上不是用来保存大量数据的，它保存的数据不能超过 1 MiB。如果需要保存更大的数据量，可以考虑使用存储卷（Volume）。</p>
<p>下面我们通过一个例子来演示如何使用 ConfigMap 假设不同环境的数据库地址不同。我们将修改之前的代码，让它从环境变量中获取 <code>DB_URL</code> 并返回该值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloKubernetes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String dbURL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取主机名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hostname = InetAddress.getLocalHost().getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            hostname = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取环境变量中的数据库连接 URL</span></span><br><span class="line">        dbURL = System.getenv(<span class="string">&quot;DB_URL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dbURL == <span class="literal">null</span>) &#123;</span><br><span class="line">            dbURL = <span class="string">&quot;not set&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HttpServer 实例，监听端口 3000</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3000</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义处理函数，当访问根路径时返回响应</span></span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpExchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> String.format(<span class="string">&quot;[v4] Hello, Kubernetes! From host: %s, Get Database Connect URL: %s&quot;</span>, hostname, dbURL);</span><br><span class="line">                exchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        server.setExecutor(<span class="literal">null</span>); <span class="comment">// 使用默认的执行器</span></span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构建镜像时，保持 Dockerfile 不变，将 <code>tag</code> 设置为 <code>v4</code>，并推送到远程仓库。如果遇到镜像拉取问题，请参考 Pod 小节中的“解决 Pod 启动失败”部分。同时，删除之前所有的资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:v4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> push 到远程仓库</span></span><br><span class="line">docker push tangrl177/hellok8s:v4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除之前所有资源</span></span><br><span class="line">kubectl delete pod,deployment,service,ingress --all</span><br></pre></td></tr></table></figure>

<p>接下来，我们在不同的 namespace 中创建 ConfigMap 来存放 <code>DB_URL</code>。</p>
<p>首先，创建 <code>hellok8s-config-dev.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s-config-dev.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DB_URL:</span> <span class="string">&quot;http://DB_ADDRESS_DEV&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后，创建 <code>hellok8s-config-test.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s-config-test.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DB_URL:</span> <span class="string">&quot;http://DB_ADDRESS_TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>分别在上一节创建的 <code>dev</code> 和 <code>test</code> 两个 namespace 中创建相同名称的 ConfigMap，名称都叫 <code>hellok8s-config</code>，但存放的键值对中的值不同。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 dev namespace 中创建 ConfigMap</span></span><br><span class="line">kubectl apply -f hellok8s-config-dev.yaml -n dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 <span class="built_in">test</span> namespace 中创建 ConfigMap</span></span><br><span class="line">kubectl apply -f hellok8s-config-test.yaml -n test </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有命名空间的 ConfigMap 信息</span></span><br><span class="line">kubectl get configmap --all-namespaces</span><br></pre></td></tr></table></figure>

<p>接下来，使用 Pod 部署 <code>hellok8s:v4</code>，并通过 ConfigMap 配置环境变量。<code>env.name</code> 表示将 ConfigMap 中的值写入环境变量，使代码能够从环境变量中获取 <code>DB_URL</code>。<code>valueFrom</code> 表示从哪里读取配置，这里使用 <code>configMapKeyRef</code> 表示从名为 <code>hellok8s-config</code> 的 ConfigMap 中读取 <code>DB_URL</code> 的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v4</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_URL</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">hellok8s-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">DB_URL</span></span><br></pre></td></tr></table></figure>

<p>最后，在 <code>dev</code> 和 <code>test</code> 两个 namespace 中分别创建 <code>hellok8s:v4</code> Pod。然后，通过 <code>port-forward</code> 的方式访问不同 namespace 的服务，你会发现返回的 <code>Get Database Connect URL</code> 对应不同的环境值，例如 <code>http://DB_ADDRESS_DEV</code> 和 <code>http://DB_ADDRESS_TEST</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f hellok8s.yaml -n dev             </span><br><span class="line">kubectl apply -f hellok8s.yaml -n test</span><br><span class="line">kubectl port-forward hellok8s-pod 3000:3000 -n dev</span><br><span class="line">curl http://localhost:3000</span><br><span class="line">kubectl port-forward hellok8s-pod 3000:3000 -n test</span><br><span class="line">curl http://localhost:3000</span><br></pre></td></tr></table></figure>

<p>通过这种方式，Kubernetes 的 ConfigMap 可以帮助我们轻松管理不同环境下的配置，确保在不同环境中部署时，能够正确使用相应的数据库地址或其他配置信息。</p>
<h3 id="使用-Secret-管理敏感信息"><a href="#使用-Secret-管理敏感信息" class="headerlink" title="使用 Secret 管理敏感信息"></a>使用 Secret 管理敏感信息</h3><p>之前我们提到，通常会选择使用 ConfigMap 来挂载配置信息，但当我们的配置信息需要加密时，ConfigMap 就无法满足这个要求。例如，当需要挂载数据库密码时，ConfigMap 只能以明文方式进行挂载，这就带来了安全隐患。</p>
<p>为了解决这一问题，Kubernetes 提供了 Secret 来存储加密信息。虽然 Secret 在资源文件中仅通过 Base64 方式进行了简单编码，但在实际生产过程中，可以结合 CI&#x2F;CD pipeline 或专业的密钥管理服务（如 <a target="_blank" rel="noopener" href="https://aws.amazon.com/kms/">AWS KMS</a>）来进一步保护敏感数据，从而大大降低安全风险。</p>
<p>Secret 是一种包含少量敏感信息（如密码、令牌或密钥）的对象。由于 Secret 的创建可以独立于使用它们的 Pod，因此在创建、查看和编辑 Pod 的过程中，暴露 Secret（及其数据）的风险较小。Kubernetes 和集群中的应用程序还可以采取额外的预防措施，例如避免将机密数据写入非易失性存储。</p>
<p>然而，默认情况下，Kubernetes 的 Secret 是未加密地存储在 API 服务器的底层数据存储（etcd）中的。这意味着任何拥有 API 访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以如此。此外，任何有权限在命名空间中创建 Pod 的人也能够间接获取该命名空间中的 Secret 内容。因此，为了安全地使用 Secret，请至少执行以下步骤：</p>
<ol>
<li>为 Secret <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">启用静态加密</a>。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">启用或配置 RBAC 规则</a>以限制读取和写入 Secret 数据的权限（包括间接方式）。注意，具有创建 Pod 权限的人也隐式获得了获取 Secret 内容的权限。</li>
<li>根据需要，可以使用 RBAC 等机制限制哪些主体能够创建新 Secret 或替换现有 Secret。</li>
</ol>
<p>Secret 的资源定义与 ConfigMap 结构基本一致，区别在于 <code>kind</code> 是 <code>Secret</code>，且 Value 需要使用 Base64 编码。不过，Secret 也提供了 <code>stringData</code> 字段，可以直接存储未编码的值，系统会自动处理 Base64 编码。</p>
<p>以下是如何使用 Base64 进行编码和解码的命令示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;password&quot; | base64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cGFzc3dvcmQK</span></span><br><span class="line">echo &quot;cGFzc3dvcmQK&quot; | base64 -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">password</span></span><br></pre></td></tr></table></figure>

<p>将 Base64 编码后的值填入对应的 key-value 对中，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s-secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DB_PASSWORD:</span> <span class="string">&quot;cGFzc3dvcmQK&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后，在 Pod 的定义中，使用 Secret 来设置环境变量：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hellok8s.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hellok8s-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hellok8s-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tangrl177/hellok8s:v5</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">hellok8s-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">DB_PASSWORD</span></span><br></pre></td></tr></table></figure>

<p>在代码中，可以通过读取 <code>DB_PASSWORD</code> 环境变量来获取并返回对应的字符串。Secret 的使用方法与 ConfigMap 基本一致，因此在此不再赘述。</p>
<p>按照以下步骤操作即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像并推送到远程仓库</span></span><br><span class="line">docker build . -t tangrl177/hellok8s:v5</span><br><span class="line">docker push tangrl177/hellok8s:v5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除之前所有资源</span></span><br><span class="line">kubectl delete pod,deployment,service,ingress --all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Secret 和 Pod</span></span><br><span class="line">kubectl apply -f hellok8s-secret.yaml</span><br><span class="line">kubectl apply -f hellok8s.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 port-forward 访问服务</span></span><br><span class="line">kubectl port-forward hellok8s-pod 3000:3000</span><br><span class="line">curl http://localhost:3000</span><br></pre></td></tr></table></figure>

<p>通过这种方式，Kubernetes Secret 可以帮助我们安全地管理敏感信息，例如数据库密码，从而避免将这些信息以明文形式暴露在配置文件中。</p>
<h3 id="使用-Job-和-CronJob-处理一次性任务"><a href="#使用-Job-和-CronJob-处理一次性任务" class="headerlink" title="使用 Job 和 CronJob 处理一次性任务"></a>使用 Job 和 CronJob 处理一次性任务</h3><p>在实际的开发过程中，有一类任务并不需要长期运行，它们只需要执行一次即可完成，例如一些计算任务。这类任务不适合用 Deployment 或 Pod 来管理，而是应该使用 Job 来处理。</p>
<p>Job 会创建一个或多个 Pod，并且在指定数量的 Pod 成功终止之前会继续重试 Pod 的执行。Job 会跟踪成功完成的 Pod 数量，当这个数量达到指定的阈值时，Job 就会标记为完成。删除 Job 会清除它创建的所有 Pod，而挂起 Job 会删除其所有活跃的 Pod，直到 Job 恢复执行。</p>
<p>一种常见的使用场景是，你可以创建一个 Job 对象来确保 Pod 可靠地执行任务直到完成。如果第一个 Pod 失败或被删除（例如因为节点硬件故障或重启），Job 对象会启动一个新的 Pod 来继续执行任务。</p>
<p>以下是一个 Job 的资源定义示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello-job.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">echo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>parallelism</code> 指定了最大并发执行的 Pod 数量为 3，<code>completions</code> 指定了总共需要成功执行的 Pod 数量为 5。也就是说，会同时启动 3 个 Pod 来执行任务，一旦某个 Pod 执行完成，会创建新的 Pod 继续执行，直到成功执行的 Pod 数量达到 5 为止。<code>restartPolicy: OnFailure</code> 表示如果 Pod 执行失败，会在同一节点重新启动该 Pod。</p>
<p>通过以下命令可以创建 Job，并使用 <code>kubectl get pods -w</code> 来观察 Job 创建 Pod 的过程和结果。最后，可以通过 <code>kubectl logs</code> 命令查看 Pod 的日志输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod,deployment,service,ingress --all</span><br><span class="line">kubectl apply -f hello-job.yaml</span><br><span class="line">kubectl get jobs</span><br><span class="line">kubectl get pods               </span><br><span class="line">kubectl logs -f hello-job--xxx</span><br></pre></td></tr></table></figure>

<p>Job 完成时，不会再创建新的 Pod，但已有的 Pod 通常也不会被自动删除。保留这些 Pod 可以帮助你查看日志输出，以便检查是否有错误、警告或其他诊断性信息。如果你需要删除 Job，可以使用 <code>kubectl delete -f hello-job.yaml</code>，这样会连同它创建的所有 Pod 一并删除。</p>
<h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><p><em>CronJob</em> 是另一种 Kubernetes 资源，适用于定时任务，它能够基于 Cron 表达式调度周期性 <a target="_blank" rel="noopener" href="https://kubernetes.ion/docs/concepts/workloads/controllers/job/">Jobs</a>。</p>
<p>CronJob 适合执行周期性任务，例如备份或报告生成。这些任务应该配置为定期重复执行（例如每天、每周或每月一次）。每次任务执行完毕后，Pod 会被删除，新的 Pod 会在下一个周期创建并执行任务。</p>
<p>Cron 时间表的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ┌───────────── 分钟 (0 - 59)</span><br><span class="line"># │ ┌───────────── 小时 (0 - 23)</span><br><span class="line"># │ │ ┌───────────── 月的某天 (1 - 31)</span><br><span class="line"># │ │ │ ┌───────────── 月份 (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六；在某些系统上，7 也是星期日）</span><br><span class="line"># │ │ │ │ │                          或者是 sun，mon，tue，wed，thu，fri，sat</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *</span><br></pre></td></tr></table></figure>

<p>除了需要指定 Cron 表达式外，CronJob 的使用方式与 Job 基本一致。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello-cronjob.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;* * * * *&quot;</span> <span class="comment"># 每分钟执行一次</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">echo</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">              <span class="attr">command:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 CronJob 的命令与 Job 基本相同，以下命令可以用于创建和管理 CronJob：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete job,pod,deployment,service,ingress --all</span><br><span class="line">kubectl apply -f hello-cronjob.yaml</span><br><span class="line">kubectl get cronjob                </span><br><span class="line">kubectl get pods   </span><br></pre></td></tr></table></figure>

<p>通过这些方法，Kubernetes 的 Job 和 CronJob 可以帮助你轻松管理一次性任务和定时任务，使得任务的执行更加自动化和可靠。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文带大家通过动手去操作 K8s 中常用的资源，相信已经揭开了 K8s 神秘的面纱，大大加深了你对 K8s 的理解。如果你不是运维的话，上面介绍的内容，在日常工作中往往就够用了。K8s 还有更多的资源和概念，如果想更深入学习可以去看看官方文档。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://k8s-tutorials.pages.dev/">Kubernetes 练习手册</a></p>
<p><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/">minikube</a></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.feisky.xyz/">Kubernetes 指南</a></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 官方文档</a></p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/K8s/" rel="tag">K8s</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/08/20/Notebook-%E5%95%86%E4%B8%9A%E5%8C%96%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%A0%94/">Notebook 商业化服务调研</a><a class="next" href="/2024/08/14/K8s-%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/">K8s 原理简述</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java-%E5%90%8E%E7%AB%AF/" style="font-size: 15px;">Java 后端</a> <a href="/tags/DevOps/" style="font-size: 15px;">DevOps</a> <a href="/tags/K8s/" style="font-size: 15px;">K8s</a> <a href="/tags/Jupyter-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/" style="font-size: 15px;">Jupyter 二次开发</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 联系我</i></div><ul></ul><a href="mailto:trl2025@163.com" title="Mail" target="_blank">Mail</a><ul></ul><a href="https://github.com/rongliangtang" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://space.bilibili.com/28159312" title="Bilibili" target="_blank">Bilibili</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 Tom</div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>